/* tslint:disable */
/* eslint-disable */
/**
 * Red Hat Openshift SmartEvents Fleet Manager
 * The API exposed by the fleet manager of the SmartEvents service.
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: openbridge-dev@redhat.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Action
 */
export interface Action {
    /**
     * 
     * @type {string}
     * @memberof Action
     */
    'type': string;
    /**
     * 
     * @type {object}
     * @memberof Action
     */
    'parameters': object;
}
/**
 * 
 * @export
 * @interface BaseFilter
 */
export interface BaseFilter {
    /**
     * 
     * @type {string}
     * @memberof BaseFilter
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseFilter
     */
    'key': string;
}
/**
 * 
 * @export
 * @interface BridgeError
 */
export interface BridgeError {
    /**
     * 
     * @type {number}
     * @memberof BridgeError
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof BridgeError
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof BridgeError
     */
    'reason'?: string;
    /**
     * 
     * @type {BridgeErrorType}
     * @memberof BridgeError
     */
    'type'?: BridgeErrorType;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const BridgeErrorType = {
    User: 'USER',
    Platform: 'PLATFORM'
} as const;

export type BridgeErrorType = typeof BridgeErrorType[keyof typeof BridgeErrorType];


/**
 * 
 * @export
 * @interface BridgeListResponse
 */
export interface BridgeListResponse {
    /**
     * 
     * @type {string}
     * @memberof BridgeListResponse
     */
    'kind': string;
    /**
     * 
     * @type {Array<BridgeResponse>}
     * @memberof BridgeListResponse
     */
    'items'?: Array<BridgeResponse>;
    /**
     * 
     * @type {number}
     * @memberof BridgeListResponse
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof BridgeListResponse
     */
    'size': number;
    /**
     * 
     * @type {number}
     * @memberof BridgeListResponse
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface BridgeRequest
 */
export interface BridgeRequest {
    /**
     * 
     * @type {string}
     * @memberof BridgeRequest
     */
    'name': string;
    /**
     * 
     * @type {Action}
     * @memberof BridgeRequest
     */
    'error_handler'?: Action;
    /**
     * 
     * @type {string}
     * @memberof BridgeRequest
     */
    'cloud_provider': string;
    /**
     * 
     * @type {string}
     * @memberof BridgeRequest
     */
    'region': string;
}
/**
 * 
 * @export
 * @interface BridgeResponse
 */
export interface BridgeResponse {
    /**
     * 
     * @type {string}
     * @memberof BridgeResponse
     */
    'kind': string;
    /**
     * 
     * @type {string}
     * @memberof BridgeResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BridgeResponse
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof BridgeResponse
     */
    'href': string;
    /**
     * 
     * @type {string}
     * @memberof BridgeResponse
     */
    'submitted_at': string;
    /**
     * 
     * @type {string}
     * @memberof BridgeResponse
     */
    'published_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof BridgeResponse
     */
    'modified_at'?: string;
    /**
     * 
     * @type {ManagedResourceStatus}
     * @memberof BridgeResponse
     */
    'status': ManagedResourceStatus;
    /**
     * 
     * @type {string}
     * @memberof BridgeResponse
     */
    'owner': string;
    /**
     * 
     * @type {string}
     * @memberof BridgeResponse
     */
    'endpoint'?: string;
    /**
     * 
     * @type {Action}
     * @memberof BridgeResponse
     */
    'error_handler'?: Action;
    /**
     * 
     * @type {string}
     * @memberof BridgeResponse
     */
    'cloud_provider'?: string;
    /**
     * 
     * @type {string}
     * @memberof BridgeResponse
     */
    'region'?: string;
}
/**
 * 
 * @export
 * @interface CloudProviderListResponse
 */
export interface CloudProviderListResponse {
    /**
     * 
     * @type {string}
     * @memberof CloudProviderListResponse
     */
    'kind': string;
    /**
     * 
     * @type {Array<CloudProviderResponse>}
     * @memberof CloudProviderListResponse
     */
    'items'?: Array<CloudProviderResponse>;
    /**
     * 
     * @type {number}
     * @memberof CloudProviderListResponse
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof CloudProviderListResponse
     */
    'size': number;
    /**
     * 
     * @type {number}
     * @memberof CloudProviderListResponse
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface CloudProviderResponse
 */
export interface CloudProviderResponse {
    /**
     * 
     * @type {string}
     * @memberof CloudProviderResponse
     */
    'kind': string;
    /**
     * 
     * @type {string}
     * @memberof CloudProviderResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CloudProviderResponse
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CloudProviderResponse
     */
    'href': string;
    /**
     * 
     * @type {string}
     * @memberof CloudProviderResponse
     */
    'display_name': string;
    /**
     * 
     * @type {boolean}
     * @memberof CloudProviderResponse
     */
    'enabled': boolean;
}
/**
 * 
 * @export
 * @interface CloudRegionListResponse
 */
export interface CloudRegionListResponse {
    /**
     * 
     * @type {string}
     * @memberof CloudRegionListResponse
     */
    'kind': string;
    /**
     * 
     * @type {Array<CloudRegionResponse>}
     * @memberof CloudRegionListResponse
     */
    'items'?: Array<CloudRegionResponse>;
    /**
     * 
     * @type {number}
     * @memberof CloudRegionListResponse
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof CloudRegionListResponse
     */
    'size': number;
    /**
     * 
     * @type {number}
     * @memberof CloudRegionListResponse
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface CloudRegionResponse
 */
export interface CloudRegionResponse {
    /**
     * 
     * @type {string}
     * @memberof CloudRegionResponse
     */
    'kind': string;
    /**
     * 
     * @type {string}
     * @memberof CloudRegionResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CloudRegionResponse
     */
    'display_name': string;
    /**
     * 
     * @type {boolean}
     * @memberof CloudRegionResponse
     */
    'enabled': boolean;
}
/**
 * 
 * @export
 * @interface ErrorListResponse
 */
export interface ErrorListResponse {
    /**
     * 
     * @type {string}
     * @memberof ErrorListResponse
     */
    'kind': string;
    /**
     * 
     * @type {Array<Error>}
     * @memberof ErrorListResponse
     */
    'items'?: Array<Error>;
    /**
     * 
     * @type {number}
     * @memberof ErrorListResponse
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof ErrorListResponse
     */
    'size': number;
    /**
     * 
     * @type {number}
     * @memberof ErrorListResponse
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface ErrorsList
 */
export interface ErrorsList {
    /**
     * 
     * @type {string}
     * @memberof ErrorsList
     */
    'kind': string;
    /**
     * 
     * @type {Array<Error>}
     * @memberof ErrorsList
     */
    'items'?: Array<Error>;
}
/**
 * 
 * @export
 * @interface List
 */
export interface List {
    /**
     * 
     * @type {string}
     * @memberof List
     */
    'kind': string;
    /**
     * 
     * @type {Array<object>}
     * @memberof List
     */
    'items'?: Array<object>;
    /**
     * 
     * @type {number}
     * @memberof List
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof List
     */
    'size': number;
    /**
     * 
     * @type {number}
     * @memberof List
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface ListAllOf
 */
export interface ListAllOf {
    /**
     * 
     * @type {number}
     * @memberof ListAllOf
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof ListAllOf
     */
    'size': number;
    /**
     * 
     * @type {number}
     * @memberof ListAllOf
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface ListResponse
 */
export interface ListResponse {
    /**
     * 
     * @type {string}
     * @memberof ListResponse
     */
    'kind': string;
    /**
     * 
     * @type {Array<object>}
     * @memberof ListResponse
     */
    'items'?: Array<object>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ManagedResourceStatus = {
    Accepted: 'accepted',
    Preparing: 'preparing',
    Provisioning: 'provisioning',
    Ready: 'ready',
    Deprovision: 'deprovision',
    Deleting: 'deleting',
    Deleted: 'deleted',
    Failed: 'failed'
} as const;

export type ManagedResourceStatus = typeof ManagedResourceStatus[keyof typeof ManagedResourceStatus];


/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'kind': string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'reason': string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'href': string;
}
/**
 * 
 * @export
 * @interface ObjectReference
 */
export interface ObjectReference {
    /**
     * 
     * @type {string}
     * @memberof ObjectReference
     */
    'kind': string;
    /**
     * 
     * @type {string}
     * @memberof ObjectReference
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ObjectReference
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ObjectReference
     */
    'href': string;
}
/**
 * 
 * @export
 * @interface ProcessorCatalogResponse
 */
export interface ProcessorCatalogResponse {
    /**
     * 
     * @type {string}
     * @memberof ProcessorCatalogResponse
     */
    'kind': string;
    /**
     * 
     * @type {Array<ProcessorSchemaEntryResponse>}
     * @memberof ProcessorCatalogResponse
     */
    'items'?: Array<ProcessorSchemaEntryResponse>;
}
/**
 * 
 * @export
 * @interface ProcessorListResponse
 */
export interface ProcessorListResponse {
    /**
     * 
     * @type {string}
     * @memberof ProcessorListResponse
     */
    'kind': string;
    /**
     * 
     * @type {Array<ProcessorResponse>}
     * @memberof ProcessorListResponse
     */
    'items'?: Array<ProcessorResponse>;
    /**
     * 
     * @type {number}
     * @memberof ProcessorListResponse
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof ProcessorListResponse
     */
    'size': number;
    /**
     * 
     * @type {number}
     * @memberof ProcessorListResponse
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface ProcessorRequest
 */
export interface ProcessorRequest {
    /**
     * 
     * @type {string}
     * @memberof ProcessorRequest
     */
    'name': string;
    /**
     * 
     * @type {Set<BaseFilter>}
     * @memberof ProcessorRequest
     */
    'filters'?: Set<BaseFilter>;
    /**
     * 
     * @type {string}
     * @memberof ProcessorRequest
     */
    'transformationTemplate'?: string;
    /**
     * 
     * @type {Action}
     * @memberof ProcessorRequest
     */
    'action'?: Action;
    /**
     * 
     * @type {Source}
     * @memberof ProcessorRequest
     */
    'source'?: Source;
}
/**
 * 
 * @export
 * @interface ProcessorResponse
 */
export interface ProcessorResponse {
    /**
     * 
     * @type {string}
     * @memberof ProcessorResponse
     */
    'kind': string;
    /**
     * 
     * @type {string}
     * @memberof ProcessorResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProcessorResponse
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessorResponse
     */
    'href': string;
    /**
     * 
     * @type {string}
     * @memberof ProcessorResponse
     */
    'submitted_at': string;
    /**
     * 
     * @type {string}
     * @memberof ProcessorResponse
     */
    'published_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessorResponse
     */
    'modified_at'?: string;
    /**
     * 
     * @type {ManagedResourceStatus}
     * @memberof ProcessorResponse
     */
    'status': ManagedResourceStatus;
    /**
     * 
     * @type {string}
     * @memberof ProcessorResponse
     */
    'owner': string;
    /**
     * 
     * @type {ProcessorType}
     * @memberof ProcessorResponse
     */
    'type': ProcessorType;
    /**
     * 
     * @type {Set<BaseFilter>}
     * @memberof ProcessorResponse
     */
    'filters'?: Set<BaseFilter>;
    /**
     * 
     * @type {string}
     * @memberof ProcessorResponse
     */
    'transformationTemplate'?: string;
    /**
     * 
     * @type {Action}
     * @memberof ProcessorResponse
     */
    'action'?: Action;
    /**
     * 
     * @type {Source}
     * @memberof ProcessorResponse
     */
    'source'?: Source;
}
/**
 * 
 * @export
 * @interface ProcessorSchemaEntryResponse
 */
export interface ProcessorSchemaEntryResponse {
    /**
     * 
     * @type {string}
     * @memberof ProcessorSchemaEntryResponse
     */
    'kind': string;
    /**
     * 
     * @type {string}
     * @memberof ProcessorSchemaEntryResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProcessorSchemaEntryResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ProcessorSchemaEntryResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ProcessorSchemaEntryResponse
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof ProcessorSchemaEntryResponse
     */
    'href': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ProcessorType = {
    Source: 'source',
    Sink: 'sink',
    ErrorHandler: 'error_handler'
} as const;

export type ProcessorType = typeof ProcessorType[keyof typeof ProcessorType];


/**
 * 
 * @export
 * @interface Source
 */
export interface Source {
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    'type': string;
    /**
     * 
     * @type {object}
     * @memberof Source
     */
    'parameters': object;
}

/**
 * BridgesApi - axios parameter creator
 * @export
 */
export const BridgesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a Bridge instance for the authenticated user.
         * @summary Create a Bridge instance
         * @param {BridgeRequest} [bridgeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBridge: async (bridgeRequest?: BridgeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/smartevents_mgmt/v1/bridges`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bridgeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Bridge instance of the authenticated user by ID.
         * @summary Delete a Bridge instance
         * @param {string} bridgeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBridge: async (bridgeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bridgeId' is not null or undefined
            assertParamExists('deleteBridge', 'bridgeId', bridgeId)
            const localVarPath = `/api/smartevents_mgmt/v1/bridges/{bridgeId}`
                .replace(`{${"bridgeId"}}`, encodeURIComponent(String(bridgeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Bridge instance of the authenticated user by ID.
         * @summary Get a Bridge instance
         * @param {string} bridgeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBridge: async (bridgeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bridgeId' is not null or undefined
            assertParamExists('getBridge', 'bridgeId', bridgeId)
            const localVarPath = `/api/smartevents_mgmt/v1/bridges/{bridgeId}`
                .replace(`{${"bridgeId"}}`, encodeURIComponent(String(bridgeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the list of Bridge instances for the authenticated user.
         * @summary Get the list of Bridge instances
         * @param {string} [name] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {Set<ManagedResourceStatus>} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBridges: async (name?: string, page?: number, size?: number, status?: Set<ManagedResourceStatus>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/smartevents_mgmt/v1/bridges`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (status) {
                localVarQueryParameter['status'] = Array.from(status);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Bridge instance for the authenticated user.
         * @summary Update a Bridge instance
         * @param {string} bridgeId 
         * @param {BridgeRequest} [bridgeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBridge: async (bridgeId: string, bridgeRequest?: BridgeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bridgeId' is not null or undefined
            assertParamExists('updateBridge', 'bridgeId', bridgeId)
            const localVarPath = `/api/smartevents_mgmt/v1/bridges/{bridgeId}`
                .replace(`{${"bridgeId"}}`, encodeURIComponent(String(bridgeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bridgeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BridgesApi - functional programming interface
 * @export
 */
export const BridgesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BridgesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a Bridge instance for the authenticated user.
         * @summary Create a Bridge instance
         * @param {BridgeRequest} [bridgeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBridge(bridgeRequest?: BridgeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BridgeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBridge(bridgeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a Bridge instance of the authenticated user by ID.
         * @summary Delete a Bridge instance
         * @param {string} bridgeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBridge(bridgeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBridge(bridgeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a Bridge instance of the authenticated user by ID.
         * @summary Get a Bridge instance
         * @param {string} bridgeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBridge(bridgeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BridgeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBridge(bridgeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the list of Bridge instances for the authenticated user.
         * @summary Get the list of Bridge instances
         * @param {string} [name] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {Set<ManagedResourceStatus>} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBridges(name?: string, page?: number, size?: number, status?: Set<ManagedResourceStatus>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BridgeListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBridges(name, page, size, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a Bridge instance for the authenticated user.
         * @summary Update a Bridge instance
         * @param {string} bridgeId 
         * @param {BridgeRequest} [bridgeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBridge(bridgeId: string, bridgeRequest?: BridgeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BridgeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBridge(bridgeId, bridgeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BridgesApi - factory interface
 * @export
 */
export const BridgesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BridgesApiFp(configuration)
    return {
        /**
         * Create a Bridge instance for the authenticated user.
         * @summary Create a Bridge instance
         * @param {BridgeRequest} [bridgeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBridge(bridgeRequest?: BridgeRequest, options?: any): AxiosPromise<BridgeResponse> {
            return localVarFp.createBridge(bridgeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Bridge instance of the authenticated user by ID.
         * @summary Delete a Bridge instance
         * @param {string} bridgeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBridge(bridgeId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteBridge(bridgeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Bridge instance of the authenticated user by ID.
         * @summary Get a Bridge instance
         * @param {string} bridgeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBridge(bridgeId: string, options?: any): AxiosPromise<BridgeResponse> {
            return localVarFp.getBridge(bridgeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the list of Bridge instances for the authenticated user.
         * @summary Get the list of Bridge instances
         * @param {string} [name] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {Set<ManagedResourceStatus>} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBridges(name?: string, page?: number, size?: number, status?: Set<ManagedResourceStatus>, options?: any): AxiosPromise<BridgeListResponse> {
            return localVarFp.getBridges(name, page, size, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Bridge instance for the authenticated user.
         * @summary Update a Bridge instance
         * @param {string} bridgeId 
         * @param {BridgeRequest} [bridgeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBridge(bridgeId: string, bridgeRequest?: BridgeRequest, options?: any): AxiosPromise<BridgeResponse> {
            return localVarFp.updateBridge(bridgeId, bridgeRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BridgesApi - object-oriented interface
 * @export
 * @class BridgesApi
 * @extends {BaseAPI}
 */
export class BridgesApi extends BaseAPI {
    /**
     * Create a Bridge instance for the authenticated user.
     * @summary Create a Bridge instance
     * @param {BridgeRequest} [bridgeRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BridgesApi
     */
    public createBridge(bridgeRequest?: BridgeRequest, options?: AxiosRequestConfig) {
        return BridgesApiFp(this.configuration).createBridge(bridgeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Bridge instance of the authenticated user by ID.
     * @summary Delete a Bridge instance
     * @param {string} bridgeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BridgesApi
     */
    public deleteBridge(bridgeId: string, options?: AxiosRequestConfig) {
        return BridgesApiFp(this.configuration).deleteBridge(bridgeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Bridge instance of the authenticated user by ID.
     * @summary Get a Bridge instance
     * @param {string} bridgeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BridgesApi
     */
    public getBridge(bridgeId: string, options?: AxiosRequestConfig) {
        return BridgesApiFp(this.configuration).getBridge(bridgeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the list of Bridge instances for the authenticated user.
     * @summary Get the list of Bridge instances
     * @param {string} [name] 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {Set<ManagedResourceStatus>} [status] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BridgesApi
     */
    public getBridges(name?: string, page?: number, size?: number, status?: Set<ManagedResourceStatus>, options?: AxiosRequestConfig) {
        return BridgesApiFp(this.configuration).getBridges(name, page, size, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Bridge instance for the authenticated user.
     * @summary Update a Bridge instance
     * @param {string} bridgeId 
     * @param {BridgeRequest} [bridgeRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BridgesApi
     */
    public updateBridge(bridgeId: string, bridgeRequest?: BridgeRequest, options?: AxiosRequestConfig) {
        return BridgesApiFp(this.configuration).updateBridge(bridgeId, bridgeRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CloudProvidersApi - axios parameter creator
 * @export
 */
export const CloudProvidersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get details of the Cloud Provider specified by id.
         * @summary Get Cloud Provider.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCloudProvider: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCloudProvider', 'id', id)
            const localVarPath = `/api/smartevents_mgmt/v1/cloud_providers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of supported Regions of the specified Cloud Provider.
         * @summary List Supported Cloud Regions.
         * @param {string} id 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCloudProviderRegions: async (id: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listCloudProviderRegions', 'id', id)
            const localVarPath = `/api/smartevents_mgmt/v1/cloud_providers/{id}/regions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of supported Cloud Providers.
         * @summary List Supported Cloud Providers.
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCloudProviders: async (page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/smartevents_mgmt/v1/cloud_providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CloudProvidersApi - functional programming interface
 * @export
 */
export const CloudProvidersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CloudProvidersApiAxiosParamCreator(configuration)
    return {
        /**
         * Get details of the Cloud Provider specified by id.
         * @summary Get Cloud Provider.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCloudProvider(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudProviderListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCloudProvider(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of supported Regions of the specified Cloud Provider.
         * @summary List Supported Cloud Regions.
         * @param {string} id 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCloudProviderRegions(id: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudRegionListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCloudProviderRegions(id, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of supported Cloud Providers.
         * @summary List Supported Cloud Providers.
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCloudProviders(page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudProviderListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCloudProviders(page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CloudProvidersApi - factory interface
 * @export
 */
export const CloudProvidersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CloudProvidersApiFp(configuration)
    return {
        /**
         * Get details of the Cloud Provider specified by id.
         * @summary Get Cloud Provider.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCloudProvider(id: string, options?: any): AxiosPromise<CloudProviderListResponse> {
            return localVarFp.getCloudProvider(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of supported Regions of the specified Cloud Provider.
         * @summary List Supported Cloud Regions.
         * @param {string} id 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCloudProviderRegions(id: string, page?: number, size?: number, options?: any): AxiosPromise<CloudRegionListResponse> {
            return localVarFp.listCloudProviderRegions(id, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of supported Cloud Providers.
         * @summary List Supported Cloud Providers.
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCloudProviders(page?: number, size?: number, options?: any): AxiosPromise<CloudProviderListResponse> {
            return localVarFp.listCloudProviders(page, size, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CloudProvidersApi - object-oriented interface
 * @export
 * @class CloudProvidersApi
 * @extends {BaseAPI}
 */
export class CloudProvidersApi extends BaseAPI {
    /**
     * Get details of the Cloud Provider specified by id.
     * @summary Get Cloud Provider.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProvidersApi
     */
    public getCloudProvider(id: string, options?: AxiosRequestConfig) {
        return CloudProvidersApiFp(this.configuration).getCloudProvider(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of supported Regions of the specified Cloud Provider.
     * @summary List Supported Cloud Regions.
     * @param {string} id 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProvidersApi
     */
    public listCloudProviderRegions(id: string, page?: number, size?: number, options?: AxiosRequestConfig) {
        return CloudProvidersApiFp(this.configuration).listCloudProviderRegions(id, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of supported Cloud Providers.
     * @summary List Supported Cloud Providers.
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudProvidersApi
     */
    public listCloudProviders(page?: number, size?: number, options?: AxiosRequestConfig) {
        return CloudProvidersApiFp(this.configuration).listCloudProviders(page, size, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ErrorCatalogApi - axios parameter creator
 * @export
 */
export const ErrorCatalogApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get an error from the error catalog.
         * @summary Get an error from the error catalog.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getError: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getError', 'id', id)
            const localVarPath = `/api/smartevents_mgmt/v1/errors/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the list of errors from the error catalog.
         * @summary Get the list of errors.
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getErrors: async (page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/smartevents_mgmt/v1/errors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ErrorCatalogApi - functional programming interface
 * @export
 */
export const ErrorCatalogApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ErrorCatalogApiAxiosParamCreator(configuration)
    return {
        /**
         * Get an error from the error catalog.
         * @summary Get an error from the error catalog.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getError(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BridgeError>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getError(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the list of errors from the error catalog.
         * @summary Get the list of errors.
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getErrors(page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ErrorListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getErrors(page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ErrorCatalogApi - factory interface
 * @export
 */
export const ErrorCatalogApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ErrorCatalogApiFp(configuration)
    return {
        /**
         * Get an error from the error catalog.
         * @summary Get an error from the error catalog.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getError(id: number, options?: any): AxiosPromise<BridgeError> {
            return localVarFp.getError(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the list of errors from the error catalog.
         * @summary Get the list of errors.
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getErrors(page?: number, size?: number, options?: any): AxiosPromise<ErrorListResponse> {
            return localVarFp.getErrors(page, size, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ErrorCatalogApi - object-oriented interface
 * @export
 * @class ErrorCatalogApi
 * @extends {BaseAPI}
 */
export class ErrorCatalogApi extends BaseAPI {
    /**
     * Get an error from the error catalog.
     * @summary Get an error from the error catalog.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ErrorCatalogApi
     */
    public getError(id: number, options?: AxiosRequestConfig) {
        return ErrorCatalogApiFp(this.configuration).getError(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the list of errors from the error catalog.
     * @summary Get the list of errors.
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ErrorCatalogApi
     */
    public getErrors(page?: number, size?: number, options?: AxiosRequestConfig) {
        return ErrorCatalogApiFp(this.configuration).getErrors(page, size, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProcessorsApi - axios parameter creator
 * @export
 */
export const ProcessorsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a Processor of a Bridge instance for the authenticated user.
         * @summary Create a Processor of a Bridge instance
         * @param {string} bridgeId 
         * @param {ProcessorRequest} [processorRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProcessorToBridge: async (bridgeId: string, processorRequest?: ProcessorRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bridgeId' is not null or undefined
            assertParamExists('addProcessorToBridge', 'bridgeId', bridgeId)
            const localVarPath = `/api/smartevents_mgmt/v1/bridges/{bridgeId}/processors`
                .replace(`{${"bridgeId"}}`, encodeURIComponent(String(bridgeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(processorRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Processor of a Bridge instance for the authenticated user.
         * @summary Delete a Processor of a Bridge instance
         * @param {string} bridgeId 
         * @param {string} processorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcessor: async (bridgeId: string, processorId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bridgeId' is not null or undefined
            assertParamExists('deleteProcessor', 'bridgeId', bridgeId)
            // verify required parameter 'processorId' is not null or undefined
            assertParamExists('deleteProcessor', 'processorId', processorId)
            const localVarPath = `/api/smartevents_mgmt/v1/bridges/{bridgeId}/processors/{processorId}`
                .replace(`{${"bridgeId"}}`, encodeURIComponent(String(bridgeId)))
                .replace(`{${"processorId"}}`, encodeURIComponent(String(processorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Processor of a Bridge instance for the authenticated user.
         * @summary Get a Processor of a Bridge instance
         * @param {string} bridgeId 
         * @param {string} processorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessor: async (bridgeId: string, processorId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bridgeId' is not null or undefined
            assertParamExists('getProcessor', 'bridgeId', bridgeId)
            // verify required parameter 'processorId' is not null or undefined
            assertParamExists('getProcessor', 'processorId', processorId)
            const localVarPath = `/api/smartevents_mgmt/v1/bridges/{bridgeId}/processors/{processorId}`
                .replace(`{${"bridgeId"}}`, encodeURIComponent(String(bridgeId)))
                .replace(`{${"processorId"}}`, encodeURIComponent(String(processorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the list of Processors of a Bridge instance for the authenticated user.
         * @summary Get the list of Processors of a Bridge instance
         * @param {string} bridgeId 
         * @param {string} [name] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {Set<ManagedResourceStatus>} [status] 
         * @param {ProcessorType} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProcessors: async (bridgeId: string, name?: string, page?: number, size?: number, status?: Set<ManagedResourceStatus>, type?: ProcessorType, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bridgeId' is not null or undefined
            assertParamExists('listProcessors', 'bridgeId', bridgeId)
            const localVarPath = `/api/smartevents_mgmt/v1/bridges/{bridgeId}/processors`
                .replace(`{${"bridgeId"}}`, encodeURIComponent(String(bridgeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (status) {
                localVarQueryParameter['status'] = Array.from(status);
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Processor instance Filter definition or Transformation template for the authenticated user.
         * @summary Update a Processor instance Filter definition or Transformation template.
         * @param {string} bridgeId 
         * @param {string} processorId 
         * @param {ProcessorRequest} [processorRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProcessor: async (bridgeId: string, processorId: string, processorRequest?: ProcessorRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bridgeId' is not null or undefined
            assertParamExists('updateProcessor', 'bridgeId', bridgeId)
            // verify required parameter 'processorId' is not null or undefined
            assertParamExists('updateProcessor', 'processorId', processorId)
            const localVarPath = `/api/smartevents_mgmt/v1/bridges/{bridgeId}/processors/{processorId}`
                .replace(`{${"bridgeId"}}`, encodeURIComponent(String(bridgeId)))
                .replace(`{${"processorId"}}`, encodeURIComponent(String(processorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(processorRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProcessorsApi - functional programming interface
 * @export
 */
export const ProcessorsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProcessorsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a Processor of a Bridge instance for the authenticated user.
         * @summary Create a Processor of a Bridge instance
         * @param {string} bridgeId 
         * @param {ProcessorRequest} [processorRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addProcessorToBridge(bridgeId: string, processorRequest?: ProcessorRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProcessorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addProcessorToBridge(bridgeId, processorRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a Processor of a Bridge instance for the authenticated user.
         * @summary Delete a Processor of a Bridge instance
         * @param {string} bridgeId 
         * @param {string} processorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProcessor(bridgeId: string, processorId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProcessor(bridgeId, processorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a Processor of a Bridge instance for the authenticated user.
         * @summary Get a Processor of a Bridge instance
         * @param {string} bridgeId 
         * @param {string} processorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessor(bridgeId: string, processorId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProcessorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProcessor(bridgeId, processorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the list of Processors of a Bridge instance for the authenticated user.
         * @summary Get the list of Processors of a Bridge instance
         * @param {string} bridgeId 
         * @param {string} [name] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {Set<ManagedResourceStatus>} [status] 
         * @param {ProcessorType} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProcessors(bridgeId: string, name?: string, page?: number, size?: number, status?: Set<ManagedResourceStatus>, type?: ProcessorType, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProcessorListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProcessors(bridgeId, name, page, size, status, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a Processor instance Filter definition or Transformation template for the authenticated user.
         * @summary Update a Processor instance Filter definition or Transformation template.
         * @param {string} bridgeId 
         * @param {string} processorId 
         * @param {ProcessorRequest} [processorRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProcessor(bridgeId: string, processorId: string, processorRequest?: ProcessorRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProcessorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProcessor(bridgeId, processorId, processorRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProcessorsApi - factory interface
 * @export
 */
export const ProcessorsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProcessorsApiFp(configuration)
    return {
        /**
         * Create a Processor of a Bridge instance for the authenticated user.
         * @summary Create a Processor of a Bridge instance
         * @param {string} bridgeId 
         * @param {ProcessorRequest} [processorRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProcessorToBridge(bridgeId: string, processorRequest?: ProcessorRequest, options?: any): AxiosPromise<ProcessorResponse> {
            return localVarFp.addProcessorToBridge(bridgeId, processorRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Processor of a Bridge instance for the authenticated user.
         * @summary Delete a Processor of a Bridge instance
         * @param {string} bridgeId 
         * @param {string} processorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcessor(bridgeId: string, processorId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteProcessor(bridgeId, processorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Processor of a Bridge instance for the authenticated user.
         * @summary Get a Processor of a Bridge instance
         * @param {string} bridgeId 
         * @param {string} processorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessor(bridgeId: string, processorId: string, options?: any): AxiosPromise<ProcessorResponse> {
            return localVarFp.getProcessor(bridgeId, processorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the list of Processors of a Bridge instance for the authenticated user.
         * @summary Get the list of Processors of a Bridge instance
         * @param {string} bridgeId 
         * @param {string} [name] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {Set<ManagedResourceStatus>} [status] 
         * @param {ProcessorType} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProcessors(bridgeId: string, name?: string, page?: number, size?: number, status?: Set<ManagedResourceStatus>, type?: ProcessorType, options?: any): AxiosPromise<ProcessorListResponse> {
            return localVarFp.listProcessors(bridgeId, name, page, size, status, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Processor instance Filter definition or Transformation template for the authenticated user.
         * @summary Update a Processor instance Filter definition or Transformation template.
         * @param {string} bridgeId 
         * @param {string} processorId 
         * @param {ProcessorRequest} [processorRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProcessor(bridgeId: string, processorId: string, processorRequest?: ProcessorRequest, options?: any): AxiosPromise<ProcessorResponse> {
            return localVarFp.updateProcessor(bridgeId, processorId, processorRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProcessorsApi - object-oriented interface
 * @export
 * @class ProcessorsApi
 * @extends {BaseAPI}
 */
export class ProcessorsApi extends BaseAPI {
    /**
     * Create a Processor of a Bridge instance for the authenticated user.
     * @summary Create a Processor of a Bridge instance
     * @param {string} bridgeId 
     * @param {ProcessorRequest} [processorRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessorsApi
     */
    public addProcessorToBridge(bridgeId: string, processorRequest?: ProcessorRequest, options?: AxiosRequestConfig) {
        return ProcessorsApiFp(this.configuration).addProcessorToBridge(bridgeId, processorRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Processor of a Bridge instance for the authenticated user.
     * @summary Delete a Processor of a Bridge instance
     * @param {string} bridgeId 
     * @param {string} processorId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessorsApi
     */
    public deleteProcessor(bridgeId: string, processorId: string, options?: AxiosRequestConfig) {
        return ProcessorsApiFp(this.configuration).deleteProcessor(bridgeId, processorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Processor of a Bridge instance for the authenticated user.
     * @summary Get a Processor of a Bridge instance
     * @param {string} bridgeId 
     * @param {string} processorId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessorsApi
     */
    public getProcessor(bridgeId: string, processorId: string, options?: AxiosRequestConfig) {
        return ProcessorsApiFp(this.configuration).getProcessor(bridgeId, processorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the list of Processors of a Bridge instance for the authenticated user.
     * @summary Get the list of Processors of a Bridge instance
     * @param {string} bridgeId 
     * @param {string} [name] 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {Set<ManagedResourceStatus>} [status] 
     * @param {ProcessorType} [type] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessorsApi
     */
    public listProcessors(bridgeId: string, name?: string, page?: number, size?: number, status?: Set<ManagedResourceStatus>, type?: ProcessorType, options?: AxiosRequestConfig) {
        return ProcessorsApiFp(this.configuration).listProcessors(bridgeId, name, page, size, status, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Processor instance Filter definition or Transformation template for the authenticated user.
     * @summary Update a Processor instance Filter definition or Transformation template.
     * @param {string} bridgeId 
     * @param {string} processorId 
     * @param {ProcessorRequest} [processorRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessorsApi
     */
    public updateProcessor(bridgeId: string, processorId: string, processorRequest?: ProcessorRequest, options?: AxiosRequestConfig) {
        return ProcessorsApiFp(this.configuration).updateProcessor(bridgeId, processorId, processorRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SchemaCatalogApi - axios parameter creator
 * @export
 */
export const SchemaCatalogApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the action processor JSON schema.
         * @summary Get action processor schema
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActionProcessorSchema: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getActionProcessorSchema', 'id', id)
            const localVarPath = `/api/smartevents_mgmt/v1/schemas/actions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the processor catalog with all the available sources and actions.
         * @summary Get processor catalog
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalog: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/smartevents_mgmt/v1/schemas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the source processor JSON schema.
         * @summary Get source processor schema
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSourceProcessorSchema: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSourceProcessorSchema', 'id', id)
            const localVarPath = `/api/smartevents_mgmt/v1/schemas/sources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchemaCatalogApi - functional programming interface
 * @export
 */
export const SchemaCatalogApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SchemaCatalogApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the action processor JSON schema.
         * @summary Get action processor schema
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActionProcessorSchema(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActionProcessorSchema(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the processor catalog with all the available sources and actions.
         * @summary Get processor catalog
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCatalog(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProcessorCatalogResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCatalog(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the source processor JSON schema.
         * @summary Get source processor schema
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSourceProcessorSchema(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSourceProcessorSchema(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SchemaCatalogApi - factory interface
 * @export
 */
export const SchemaCatalogApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SchemaCatalogApiFp(configuration)
    return {
        /**
         * Get the action processor JSON schema.
         * @summary Get action processor schema
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActionProcessorSchema(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.getActionProcessorSchema(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the processor catalog with all the available sources and actions.
         * @summary Get processor catalog
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalog(options?: any): AxiosPromise<ProcessorCatalogResponse> {
            return localVarFp.getCatalog(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the source processor JSON schema.
         * @summary Get source processor schema
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSourceProcessorSchema(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.getSourceProcessorSchema(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SchemaCatalogApi - object-oriented interface
 * @export
 * @class SchemaCatalogApi
 * @extends {BaseAPI}
 */
export class SchemaCatalogApi extends BaseAPI {
    /**
     * Get the action processor JSON schema.
     * @summary Get action processor schema
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaCatalogApi
     */
    public getActionProcessorSchema(id: string, options?: AxiosRequestConfig) {
        return SchemaCatalogApiFp(this.configuration).getActionProcessorSchema(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the processor catalog with all the available sources and actions.
     * @summary Get processor catalog
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaCatalogApi
     */
    public getCatalog(options?: AxiosRequestConfig) {
        return SchemaCatalogApiFp(this.configuration).getCatalog(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the source processor JSON schema.
     * @summary Get source processor schema
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaCatalogApi
     */
    public getSourceProcessorSchema(id: string, options?: AxiosRequestConfig) {
        return SchemaCatalogApiFp(this.configuration).getSourceProcessorSchema(id, options).then((request) => request(this.axios, this.basePath));
    }
}


